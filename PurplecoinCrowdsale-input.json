{"language":"Solidity","sources":{"openzeppelin-solidity/contracts/access/Roles.sol":{"content":"pragma solidity ^0.4.24;\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n  struct Role {\n    mapping (address => bool) bearer;\n  }\n\n  /**\n   * @dev give an account access to this role\n   */\n  function add(Role storage role, address account) internal {\n    require(account != address(0));\n    require(!has(role, account));\n\n    role.bearer[account] = true;\n  }\n\n  /**\n   * @dev remove an account's access to this role\n   */\n  function remove(Role storage role, address account) internal {\n    require(account != address(0));\n    require(has(role, account));\n\n    role.bearer[account] = false;\n  }\n\n  /**\n   * @dev check if an account has this role\n   * @return bool\n   */\n  function has(Role storage role, address account)\n    internal\n    view\n    returns (bool)\n  {\n    require(account != address(0));\n    return role.bearer[account];\n  }\n}\n"},"openzeppelin-solidity/contracts/access/roles/MinterRole.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"../Roles.sol\";\n\ncontract MinterRole {\n  using Roles for Roles.Role;\n\n  event MinterAdded(address indexed account);\n  event MinterRemoved(address indexed account);\n\n  Roles.Role private minters;\n\n  constructor() internal {\n    _addMinter(msg.sender);\n  }\n\n  modifier onlyMinter() {\n    require(isMinter(msg.sender));\n    _;\n  }\n\n  function isMinter(address account) public view returns (bool) {\n    return minters.has(account);\n  }\n\n  function addMinter(address account) public onlyMinter {\n    _addMinter(account);\n  }\n\n  function renounceMinter() public {\n    _removeMinter(msg.sender);\n  }\n\n  function _addMinter(address account) internal {\n    minters.add(account);\n    emit MinterAdded(account);\n  }\n\n  function _removeMinter(address account) internal {\n    minters.remove(account);\n    emit MinterRemoved(account);\n  }\n}\n"},"openzeppelin-solidity/contracts/math/SafeMath.sol":{"content":"pragma solidity ^0.4.24;\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, reverts on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b);\n\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  }\n\n  /**\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  /**\n  * @dev Adds two numbers, reverts on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a);\n\n    return c;\n  }\n\n  /**\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n  * reverts when dividing by zero.\n  */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0);\n    return a % b;\n  }\n}\n"},"openzeppelin-solidity/contracts/token/ERC20/ERC20.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n * Originally based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract ERC20 is IERC20 {\n  using SafeMath for uint256;\n\n  mapping (address => uint256) private _balances;\n\n  mapping (address => mapping (address => uint256)) private _allowed;\n\n  uint256 private _totalSupply;\n\n  /**\n  * @dev Total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return _totalSupply;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param owner The address to query the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address owner) public view returns (uint256) {\n    return _balances[owner];\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param owner address The address which owns the funds.\n   * @param spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(\n    address owner,\n    address spender\n   )\n    public\n    view\n    returns (uint256)\n  {\n    return _allowed[owner][spender];\n  }\n\n  /**\n  * @dev Transfer token for a specified address\n  * @param to The address to transfer to.\n  * @param value The amount to be transferred.\n  */\n  function transfer(address to, uint256 value) public returns (bool) {\n    _transfer(msg.sender, to, value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param spender The address which will spend the funds.\n   * @param value The amount of tokens to be spent.\n   */\n  function approve(address spender, uint256 value) public returns (bool) {\n    require(spender != address(0));\n\n    _allowed[msg.sender][spender] = value;\n    emit Approval(msg.sender, spender, value);\n    return true;\n  }\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param from address The address which you want to send tokens from\n   * @param to address The address which you want to transfer to\n   * @param value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  )\n    public\n    returns (bool)\n  {\n    require(value <= _allowed[from][msg.sender]);\n\n    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n    _transfer(from, to, value);\n    return true;\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed_[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param spender The address which will spend the funds.\n   * @param addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseAllowance(\n    address spender,\n    uint256 addedValue\n  )\n    public\n    returns (bool)\n  {\n    require(spender != address(0));\n\n    _allowed[msg.sender][spender] = (\n      _allowed[msg.sender][spender].add(addedValue));\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed_[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param spender The address which will spend the funds.\n   * @param subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseAllowance(\n    address spender,\n    uint256 subtractedValue\n  )\n    public\n    returns (bool)\n  {\n    require(spender != address(0));\n\n    _allowed[msg.sender][spender] = (\n      _allowed[msg.sender][spender].sub(subtractedValue));\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n    return true;\n  }\n\n  /**\n  * @dev Transfer token for a specified addresses\n  * @param from The address to transfer from.\n  * @param to The address to transfer to.\n  * @param value The amount to be transferred.\n  */\n  function _transfer(address from, address to, uint256 value) internal {\n    require(value <= _balances[from]);\n    require(to != address(0));\n\n    _balances[from] = _balances[from].sub(value);\n    _balances[to] = _balances[to].add(value);\n    emit Transfer(from, to, value);\n  }\n\n  /**\n   * @dev Internal function that mints an amount of the token and assigns it to\n   * an account. This encapsulates the modification of balances such that the\n   * proper events are emitted.\n   * @param account The account that will receive the created tokens.\n   * @param value The amount that will be created.\n   */\n  function _mint(address account, uint256 value) internal {\n    require(account != 0);\n    _totalSupply = _totalSupply.add(value);\n    _balances[account] = _balances[account].add(value);\n    emit Transfer(address(0), account, value);\n  }\n\n  /**\n   * @dev Internal function that burns an amount of the token of a given\n   * account.\n   * @param account The account whose tokens will be burnt.\n   * @param value The amount that will be burnt.\n   */\n  function _burn(address account, uint256 value) internal {\n    require(account != 0);\n    require(value <= _balances[account]);\n\n    _totalSupply = _totalSupply.sub(value);\n    _balances[account] = _balances[account].sub(value);\n    emit Transfer(account, address(0), value);\n  }\n\n  /**\n   * @dev Internal function that burns an amount of the token of a given\n   * account, deducting from the sender's allowance for said account. Uses the\n   * internal burn function.\n   * @param account The account whose tokens will be burnt.\n   * @param value The amount that will be burnt.\n   */\n  function _burnFrom(address account, uint256 value) internal {\n    require(value <= _allowed[account][msg.sender]);\n\n    // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,\n    // this function needs to emit an event with the updated approval.\n    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(\n      value);\n    _burn(account, value);\n  }\n}\n"},"openzeppelin-solidity/contracts/token/ERC20/ERC20Burnable.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./ERC20.sol\";\n\n/**\n * @title Burnable Token\n * @dev Token that can be irreversibly burned (destroyed).\n */\ncontract ERC20Burnable is ERC20 {\n\n  /**\n   * @dev Burns a specific amount of tokens.\n   * @param value The amount of token to be burned.\n   */\n  function burn(uint256 value) public {\n    _burn(msg.sender, value);\n  }\n\n  /**\n   * @dev Burns a specific amount of tokens from the target address and decrements allowance\n   * @param from address The address which you want to send tokens from\n   * @param value uint256 The amount of token to be burned\n   */\n  function burnFrom(address from, uint256 value) public {\n    _burnFrom(from, value);\n  }\n}\n"},"openzeppelin-solidity/contracts/token/ERC20/ERC20Detailed.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./IERC20.sol\";\n\n/**\n * @title ERC20Detailed token\n * @dev The decimals are only for visualization purposes.\n * All the operations are done using the smallest and indivisible token unit,\n * just as on Ethereum all the operations are done in wei.\n */\ncontract ERC20Detailed is IERC20 {\n  string private _name;\n  string private _symbol;\n  uint8 private _decimals;\n\n  constructor(string name, string symbol, uint8 decimals) public {\n    _name = name;\n    _symbol = symbol;\n    _decimals = decimals;\n  }\n\n  /**\n   * @return the name of the token.\n   */\n  function name() public view returns(string) {\n    return _name;\n  }\n\n  /**\n   * @return the symbol of the token.\n   */\n  function symbol() public view returns(string) {\n    return _symbol;\n  }\n\n  /**\n   * @return the number of decimals of the token.\n   */\n  function decimals() public view returns(uint8) {\n    return _decimals;\n  }\n}\n"},"openzeppelin-solidity/contracts/token/ERC20/ERC20Mintable.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./ERC20.sol\";\nimport \"../../access/roles/MinterRole.sol\";\n\n/**\n * @title ERC20Mintable\n * @dev ERC20 minting logic\n */\ncontract ERC20Mintable is ERC20, MinterRole {\n  /**\n   * @dev Function to mint tokens\n   * @param to The address that will receive the minted tokens.\n   * @param value The amount of tokens to mint.\n   * @return A boolean that indicates if the operation was successful.\n   */\n  function mint(\n    address to,\n    uint256 value\n  )\n    public\n    onlyMinter\n    returns (bool)\n  {\n    _mint(to, value);\n    return true;\n  }\n}\n"},"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol":{"content":"pragma solidity ^0.4.24;\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ninterface IERC20 {\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address who) external view returns (uint256);\n\n  function allowance(address owner, address spender)\n    external view returns (uint256);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function approve(address spender, uint256 value)\n    external returns (bool);\n\n  function transferFrom(address from, address to, uint256 value)\n    external returns (bool);\n\n  event Transfer(\n    address indexed from,\n    address indexed to,\n    uint256 value\n  );\n\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n}\n"},"project:/contracts/MathHelp.sol":{"content":"pragma solidity ^0.4.24;\n\ncontract MathHelp {\n    function getPercentAmount(uint amount, uint percentage, uint precision) public\n    constant returns (uint totalAmount){\n        return ((amount * (percentage * power(10, precision +1)) / (1000 * power(10, precision))));\n    }\n\n    function power(uint256 A, uint256 B) public\n    constant returns (uint result){\n        return A ** B;\n    }\n\n}\n"},"project:/contracts/Ownable.sol":{"content":"pragma solidity ^0.4.24;\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n    address public owner;\n\n    event OwnershipRenounced(address indexed previousOwner);\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n\n    /**\n     * @dev Allows the current owner to relinquish control of the contract.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipRenounced(owner);\n        owner = address(0);\n    }\n}\n"},"project:/contracts/PurplecoinCrowdsale.sol":{"content":"pragma solidity ^0.4.24;\n\n/// @custom:security-contact security@purpletech.io\n\nimport \"openzeppelin-solidity/contracts/token/ERC20/ERC20Detailed.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/ERC20Mintable.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/ERC20Burnable.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport './MathHelp.sol';\nimport \"./Ownable.sol\";\n\ncontract Purplecoin is ERC20Detailed, ERC20Mintable, ERC20Burnable {\n    constructor() public ERC20Detailed(\"Purplecoin\", \"XPU\", 18) {}\n\n    /**\n     * Event for burning tokens\n     * @param burner The address burning the tokens\n     * @param value amount of tokens burnt\n     * @param message burn additional data\n     */\n    event TokenBurn(\n        address burner,\n        uint256 value,\n        string message\n    );\n\n    /**\n     * @dev Burn tokens with message. Used to transfer coins to the main chain when message is a Purplecoin address.\n     * @param value amount of tokens to be burnt\n     * @param message additional data\n     */\n    function burn(uint256 value, string message) public {\n        super.burn(value);\n        emit TokenBurn(msg.sender, value, message);\n    }\n\n    /**\n     * @dev Burn tokens from address with message. Used to transfer coins to the main chain when message is a Purplecoin address.\n     * @param account account to burn tokens from\n     * @param value amount of tokens to be burnt\n     * @param message additional data\n     */\n    function burnFrom(address account, uint256 value, string message) public {\n        super.burnFrom(account, value);\n        emit TokenBurn(account, value, message);\n    }\n}\n\ncontract PurplecoinCrowdsale is Ownable {\n    using SafeMath for uint256;\n\n    uint256 stage = 0;\n\n    // Mapping of KYC authorisations\n    mapping(address => bool) public kyc_authorised;\n\n    // Mapping of Pending purchases \n    mapping(address => bool) public pending;\n\n    // Mapping of pending Wei\n    mapping(address => uint256) public pending_wei;\n\n    // Mapping of pending psats \n    mapping(address => uint256) public pending_psats;\n\n    // Balances\n    mapping(address => uint256) private _balances;\n\n    // Wei raised per address\n    mapping(address => uint256) private _wei_raised_per_address;\n\n    MathHelp math = new MathHelp();\n\n    // Amount sold, refunded, and in escrow\n    // --------------------------\n    uint256 public totalPsatsInEscrow;\n    uint256 public totalWeiInEscrow;\n    uint256 public totalSoldPsats;\n    uint256 public totalWeiInSettledEscrow;\n\n    // -----------------------\n    uint256 public tokensCap;\n    uint256 public individualTokensCap;\n    uint256 private bonus;\n    uint256[] private WAVE_CAPS;\n    uint256[] private WAVE_BONUSES;\n    bool public isFinalized;\n    ERC20Mintable public token;\n\n    // Address where funds are collected\n    address public wallet;\n\n    // How many token units a buyer gets per wei\n    uint256 public rate;\n\n    // Amount of wei raised\n    uint256 public weiRaised;\n\n    // Minimum buy amount\n    uint256 public minBuy;\n\n    /// @dev counter to allow mutex lock with only one SSTORE operation\n    uint256 private _guardCounter;\n\n    constructor(uint256 _rate, uint256 _coins, uint256[] _waveCaps, uint256[] _waveBonuses, address _wallet) public {\n        wallet = _wallet;\n        uint256 decimals = 10 ** 18; // 18 decimal places\n        tokensCap = _coins * decimals;\n        _waveCaps[0] = 37999000000000000000000000;\n        _waveCaps[1] = 75998000000000000000000000;\n        _waveCaps[2] = 113997001000000000000000000;\n        individualTokensCap = 500000000000000000000000; // Max 500,000 XPU per person \n        minBuy = 10000000000000000; // 0.01 ETH min buy\n        rate = _rate;\n        token = createTokenContract();\n        WAVE_CAPS = _waveCaps;\n        WAVE_BONUSES = _waveBonuses;\n        setCrowdsaleStage(0); //set in pre Sale stage\n\n        // Init balances\n        _balances[0x25E320b95316bAA3d300155aD82A0aEBEE400E66] = 1821600000000000000000; // https://etherscan.io/tx/0x7ae5653adfdeb4f0ec8c7d1e3de11edbc84cac4c0a6fbf5141a9c49b5481497b\n\n        // Dev fund, 0.5% of the supply\n        _balances[0x130fCeAD624C57aB46EF073bd1a940ACF8Bf2c85] = 11399700000000000000000000;\n\n        // The counter starts at one to prevent changing it from zero to a non-zero\n        // value, which is a more expensive operation.\n        _guardCounter = 1;\n    }\n\n    // ==============================\n\n    // Events\n    // ---------------------\n    event EthTransferred(uint256 amount);\n    event PurchaseCancelled(address indexed beneficiary);\n    event KycAuthorised(address indexed beneficiary);\n    event IncrementWave(uint256 newWave);\n    event TokenMint(address indexed beneficiary, uint256 amount);\n    event CrowdsaleFinalized();\n\n    /**\n     * Event for token purchase logging\n     * @param purchaser who paid for the tokens\n     * @param beneficiary who got the tokens\n     * @param value weis paid for purchase\n     * @param amount amount of tokens purchased\n     */\n    event TokenPurchase(\n        address indexed purchaser,\n        address indexed beneficiary,\n        bool authorised,\n        uint256 value,\n        uint256 amount\n    );\n\n    /**\n     * @dev fallback function ***DO NOT OVERRIDE***\n     * Note that other contracts will transfer fund with a base gas stipend\n     * of 2300, which is not enough to call buyTokens. Consider calling\n     * buyTokens directly when purchasing tokens from a contract.\n     */\n    function () external payable {\n        buyTokens(msg.sender);\n    }\n\n    /**\n     * @dev Reverts if beneficiary is not authorized. Can be used when extending this contract.\n     * @param _beneficiary beneficiary address\n     */\n    modifier isAuthorised(address _beneficiary) {\n        require(kyc_authorised[_beneficiary]);\n        _;\n    }\n\n    /**\n     * @dev Reverts if beneficiary is not pending. Can be used when extending this contract.\n     */\n    modifier isPending(address _beneficiary) {\n        require(pending[_beneficiary]);\n        _;\n    }\n\n    // Reentrancy Guard\n    // -----------------------\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _guardCounter += 1;\n        uint256 localCounter = _guardCounter;\n        _;\n        require(localCounter == _guardCounter);\n    }\n\n    // Post delivery\n    // -----------------------\n\n    /**\n     * @dev Withdraw tokens only after crowdsale ends.\n     * @param _beneficiary Whose tokens will be withdrawn.\n     */\n    function withdrawTokens(address _beneficiary) nonReentrant public {\n        require(isFinalized);\n        uint256 amount = _balances[_beneficiary];\n        require(amount > 0);\n        _balances[_beneficiary] = 0;\n        _deliverTokens(_beneficiary, amount);\n    }\n\n    /**\n     * @return the balance of an account.\n     */\n    function balanceOf(address account) public view returns(uint256) {\n        return _balances[account];\n    }\n\n    // Crowdsale Stages\n    // -----------------------\n\n    // Change Crowdsale Stage.\n    function setCrowdsaleStage(uint256 _stage) private {\n        setCurrentBonus(WAVE_BONUSES[_stage]);\n        stage = _stage;\n    }\n\n    function getCurrentStage() public constant returns (uint256){\n        return stage;\n    }\n\n\n    function currentWaveCap() public constant returns (uint256) {\n        return WAVE_CAPS[stage];\n    }\n\n    function incrementWave() private {\n        stage = stage + 1;\n        emit IncrementWave(stage);\n        return;\n    }\n\n    // Change the current bonus\n    function setCurrentBonus(uint256 _bonus) private {\n        bonus = _bonus;\n        return;\n    }\n\n    //---------------------------end stages----------------------------------\n\n    // creates the token to be sold.\n    // override this method to have crowdsale of a specific ERC20Mintable token.\n    function createTokenContract() internal returns (ERC20Mintable) {\n        return new Purplecoin();\n    }\n\n    function _shouldIncrementWave(uint256 _currentWaveCap) constant internal returns (bool){\n        return totalSoldPsats.add(totalPsatsInEscrow) >= _currentWaveCap;\n    }\n\n    // Override to execute any logic once the crowdsale finalizes\n    // Requires a call to the public finalize method\n    function finalization() internal {\n        // mint the rest of the tokens\n        // if (token.totalSupply() < tokensCap) {\n        //     mintTokens(remainingTokensWallet, tokensCap.sub(token.totalSupply()));\n        // }\n        //no more tokens from now on\n        //token.finishMinting();\n        emit CrowdsaleFinalized();\n    }\n\n    function finalize() public onlyOwner {\n        require(!isFinalized);\n        finalization();\n        isFinalized = true;\n    }\n\n    function clearWeiInSettledEscrow() public onlyOwner {\n        require(totalWeiInSettledEscrow > 0);\n        wallet.transfer(totalWeiInSettledEscrow);\n        emit EthTransferred(totalWeiInSettledEscrow);\n        totalWeiInSettledEscrow = 0;\n    }\n\n\n    function mintTokens(address _beneficiary, uint256 tokens) internal {\n        require(_beneficiary != 0x0);\n        // Cannot mint before sale is closed\n        require(isFinalized);\n        token.mint(_beneficiary, tokens);\n        emit TokenMint(_beneficiary, tokens);\n    }\n\n    /**\n     * @dev Update the rate\n     * @param _rate new rate\n     */\n    function updateRate(uint256 _rate) public onlyOwner {\n        require(!isFinalized);\n        rate = _rate;\n    }\n\n    /**\n     * @dev Update the minBuy\n     * @param _minBuy new minBuy\n     */\n    function updateMinBuy(uint256 _minBuy) public onlyOwner {\n        require(!isFinalized);\n        minBuy = _minBuy;\n    }\n\n    /**\n     * @dev Update the individualTokensCap\n     * @param _individualTokensCap new individualTokensCap\n     */\n    function updateIndividualTokensCap(uint256 _individualTokensCap) public onlyOwner {\n        require(!isFinalized);\n        individualTokensCap = _individualTokensCap;\n    }\n\n    // KYC\n    // -----------------------\n\n    /**\n     * @dev Authorise token transfer for address.\n     * @param _beneficiary beneficiary address\n     */\n    function authorise(address _beneficiary) public nonReentrant isPending(_beneficiary) onlyOwner {\n        emit KycAuthorised(_beneficiary);\n        _forwardPendingFunds(_beneficiary);\n    }\n\n    /**\n     * @dev Authorise token transfers for a batch of addresses.\n     * @param _beneficiaries Beneficiaries array\n     */\n    function authoriseMany(address[] _beneficiaries) external nonReentrant onlyOwner {\n        for(uint256 i=0; i < _beneficiaries.length; i++) {\n            authorise(_beneficiaries[i]);\n        }\n    }\n\n    function withdrawalAllowed(address _beneficiary) public view returns(bool) {\n        return kyc_authorised[_beneficiary];\n    }\n\n    // Crowdsale overrides\n    // -----------------------\n\n    // Override this method to have a way to add business logic to your crowdsale when buying\n    // Returns weiAmount times rate by default\n    function _getTokenAmount(uint256 weiAmount) internal view returns (uint256) {\n        return rate.mul(weiAmount.add(math.getPercentAmount(weiAmount, bonus, 18)));\n    }\n\n    function cancelPurchase() public nonReentrant isPending(msg.sender) {\n        require(pending_wei[msg.sender] != 0);\n        uint256 to_refund = pending_wei[msg.sender];\n        totalWeiInEscrow = totalWeiInEscrow.sub(pending_wei[msg.sender]);\n        totalPsatsInEscrow = totalPsatsInEscrow.sub(pending_psats[msg.sender]);\n        pending[msg.sender] = false;\n        pending_wei[msg.sender] = 0;\n        pending_psats[msg.sender] = 0;\n        msg.sender.transfer(to_refund);\n        emit PurchaseCancelled(msg.sender);\n    }\n\n    function cancelPurchaseFor(address _beneficiary) public nonReentrant isPending(_beneficiary) onlyOwner {\n        require(pending_wei[_beneficiary] != 0);\n        uint256 to_refund = pending_wei[_beneficiary];\n        totalWeiInEscrow = totalWeiInEscrow.sub(pending_wei[_beneficiary]);\n        totalPsatsInEscrow = totalPsatsInEscrow.sub(pending_psats[_beneficiary]);\n        pending[_beneficiary] = false;\n        pending_wei[_beneficiary] = 0;\n        pending_psats[_beneficiary] = 0;\n        _beneficiary.transfer(to_refund);\n        emit PurchaseCancelled(_beneficiary);\n    }\n\n    /**\n     * @dev low level token purchase ***DO NOT OVERRIDE***\n     * @param _beneficiary Address performing the token purchase\n     */\n    function buyTokens(address _beneficiary) public nonReentrant payable {\n        uint256 weiAmount = msg.value;\n        _preValidatePurchase(_beneficiary, weiAmount);\n\n        // calculate token amount to be created\n        uint256 tokens = _getTokenAmount(weiAmount);\n\n        _processPurchase(_beneficiary, tokens);\n        emit TokenPurchase(msg.sender, _beneficiary, kyc_authorised[_beneficiary], weiAmount, tokens);\n\n        _forwardFunds(_beneficiary);\n    }\n\n    /**\n     * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use `super` in contracts that inherit from Crowdsale to extend their validations.\n     * Example from CappedCrowdsale.sol's _preValidatePurchase method:\n     *   super._preValidatePurchase(beneficiary, weiAmount);\n     *   require(weiRaised().add(weiAmount) <= cap);\n     * @param beneficiary Address performing the token purchase\n     * @param weiAmount Value in wei involved in the purchase\n    */\n    function _preValidatePurchase(\n        address beneficiary,\n        uint256 weiAmount\n    )\n        internal\n        view\n    {\n        uint256 tokenAmount = _getTokenAmount(weiAmount);\n        require(beneficiary != address(0));\n        require(_wei_raised_per_address[beneficiary].add(pending_wei[beneficiary]).add(weiAmount) >= minBuy);    // Min buy\n        require(!isFinalized);\n        require(_balances[beneficiary].add(pending_psats[beneficiary]).add(tokenAmount) <= individualTokensCap); // Individual cap\n        require(tokenAmount.add(totalSoldPsats).add(totalPsatsInEscrow) <= tokensCap);                           // Sale cap\n    }\n\n    /**\n     * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens.\n     * @param _beneficiary Address performing the token purchase\n     * @param _tokenAmount Number of tokens to be emitted\n     */\n    function _deliverTokens(address _beneficiary, uint256 _tokenAmount) \n        internal \n        isAuthorised(_beneficiary) \n    {\n        mintTokens(_beneficiary, _tokenAmount);\n    }\n\n    /**\n     * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.\n     * @param _beneficiary Address receiving the tokens\n     * @param _tokenAmount Number of tokens to be purchased\n     */\n    function _processPurchase(address _beneficiary, uint256 _tokenAmount)\n        internal\n    {\n        if (kyc_authorised[_beneficiary]) {\n            weiRaised = weiRaised.add(msg.value);\n            _wei_raised_per_address[_beneficiary] = _wei_raised_per_address[_beneficiary].add(msg.value);\n            _balances[_beneficiary] = _balances[_beneficiary].add(_tokenAmount);\n            totalSoldPsats = totalSoldPsats.add(_tokenAmount);\n        } else {\n            kyc_authorised[_beneficiary] = false;\n            pending[_beneficiary] = true;\n            pending_psats[_beneficiary] = pending_psats[_beneficiary].add(_tokenAmount);\n            totalPsatsInEscrow = totalPsatsInEscrow.add(_tokenAmount);\n            if (_shouldIncrementWave(currentWaveCap())) {\n                incrementWave();\n            }\n        }\n    }\n\n    // Override to create custom fund forwarding mechanisms\n    // Forwards funds to the specified wallet by default\n    function _forwardFunds(address _beneficiary) internal {\n        if (kyc_authorised[_beneficiary]) {\n            if (_shouldIncrementWave(currentWaveCap())) {\n                incrementWave();\n            }\n            totalWeiInSettledEscrow = totalWeiInSettledEscrow.add(msg.value);\n        } else {\n            pending_wei[_beneficiary] = pending_wei[_beneficiary].add(msg.value);\n            totalWeiInEscrow = totalWeiInEscrow.add(msg.value);\n        }\n    }\n\n    // Override to create custom pending fund forwarding mechanisms\n    // Forwards funds to the specified wallet by default\n    function _forwardPendingFunds(address _beneficiary) internal {\n        weiRaised = weiRaised.add(pending_wei[_beneficiary]);\n        _wei_raised_per_address[_beneficiary] = _wei_raised_per_address[_beneficiary].add(pending_wei[_beneficiary]);\n        totalWeiInEscrow = totalWeiInEscrow.sub(pending_wei[_beneficiary]);\n        totalSoldPsats = totalSoldPsats.add(pending_psats[_beneficiary]);\n        totalPsatsInEscrow = totalPsatsInEscrow.sub(pending_psats[_beneficiary]);\n        \n        _balances[_beneficiary] = _balances[_beneficiary].add(pending_psats[_beneficiary]);\n        wallet.transfer(pending_wei[_beneficiary]);\n        emit EthTransferred(pending_wei[_beneficiary]);\n\n        pending_wei[_beneficiary] = 0;\n        pending_psats[_beneficiary] = 0;\n        kyc_authorised[_beneficiary] = true;\n        pending[_beneficiary] = false;\n    }\n}"}},"settings":{"remappings":[],"optimizer":{"enabled":false,"runs":200},"evmVersion":"byzantium"}}